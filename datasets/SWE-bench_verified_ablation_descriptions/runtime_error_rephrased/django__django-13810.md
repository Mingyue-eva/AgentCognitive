MiddlewareNotUsed leaves undesired side effects when loading middleware in ASGI context

I experienced strange issues when working with ASGI, django-debug-toolbar and my own small middleware. It was a hard problem to debug, so I uploaded an example project here: https://github.com/hbielenia/asgi-djangotoolbar-bug (the name is misleading—I initially thought it was a bug with django-debug-toolbar).  
The SESSION_FILE_PATH setting is intentionally broken to cause a 500 error. When I start the application and navigate to /admin (or any other path), Django attempts to await the HttpResponse object and throws a TypeError, because HttpResponse is not an awaitable coroutine. Commenting out asgi_djangotoolbar_bug.middleware.DummyMiddleware fixes the issue (in that I receive a 500 ImproperlyConfigured exception). I’m not sure about the overall role of django-debug-toolbar here—removing it causes Daphne to return a 500 error page but without debug information and no traceback in the console. I decided to leave it since it helped me approximate the causes of the issue.

I notice that in https://github.com/django/django/blob/3.1.4/django/core/handlers/base.py#L58 while MiddlewareNotUsed causes the loop to skip further processing and go to the next middleware, it does leave the handler variable overwritten with the output of self.adapt_method_mode(). On the next pass, this handler is passed to the next middleware instance, disregarding all the previous checks for (lack of) async support. This likely poisons the middleware chain from this point onwards, causing the last middleware in the response cycle to return an HttpResponse as a synchronous middleware would, instead of a coroutine as expected.

This is probably avoided by adding async support to my middleware, but unless I’m missing something, the docs indicate it should work as it is. It is my intention that it only applies to synchronous requests, so I didn’t make it async-compatible on purpose. If it’s intentional in Django that every middleware needs to support async when the application is run as an ASGI app, the documentation should probably state that clearly, though that kind of defeats the purpose of having the async_capable = False flag in the first place.